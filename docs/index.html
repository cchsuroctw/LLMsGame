<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ‰“ç£šå¡Š Breakoutï¼ˆHTML/CSS/JSï¼‰</title>
  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.10);
      --text: #eaf0ff;
      --muted: rgba(234,240,255,.75);
      --accent: #6ee7ff;
      --danger: #ff6b6b;
      --ok: #48ff95;
    }
    *{ box-sizing: border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: radial-gradient(1000px 700px at 15% 0%, #1a2560 0%, var(--bg) 55%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", sans-serif;
      color: var(--text);
    }
    .wrap{
      width: min(1100px, 100%);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap: 14px;
    }
    @media (max-width: 900px){
      .wrap{ grid-template-columns: 1fr; }
    }

    .stage{
      position: relative;
      border-radius: 16px;
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
    }
    canvas{
      display:block;
      width: 100%;
      height: auto;
      background:
        radial-gradient(800px 500px at 50% 15%, rgba(110,231,255,.12), transparent 60%),
        radial-gradient(700px 450px at 20% 60%, rgba(72,255,149,.10), transparent 55%),
        #070b16;
    }
    .hudOverlay{
      position:absolute;
      inset: 0;
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .message{
      max-width: 520px;
      text-align:center;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 16px 18px;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
      display:none;
    }
    .message.show{ display:block; }
    .message h2{
      margin: 0 0 8px;
      font-size: 20px;
      letter-spacing: .4px;
    }
    .message p{
      margin: 8px 0 0;
      color: var(--muted);
      line-height: 1.6;
      font-size: 13px;
    }

    .side{
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .title{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: 10px;
    }
    .title h1{
      margin:0;
      font-size: 18px;
      letter-spacing: .4px;
    }
    .title .sub{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
      line-height:1.3;
    }

    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .card{
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 12px;
    }
    .card .label{ font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .card .value{ font-size: 18px; font-weight: 800; letter-spacing:.4px; }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .05s ease, background .2s ease, border-color .2s ease;
      font-weight: 700;
      letter-spacing: .2px;
    }
    button:hover{
      background: rgba(255,255,255,.12);
      border-color: rgba(255,255,255,.20);
    }
    button:active{ transform: translateY(1px); }
    .primary{ border-color: rgba(110,231,255,.35); }
    .danger{ border-color: rgba(255,107,107,.35); }

    .help{
      background: rgba(0,0,0,.22);
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 14px;
      padding: 12px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      padding: 2px 6px;
      border-radius: 8px;
      color: var(--accent);
      font-weight: 800;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <canvas id="game" width="960" height="600"></canvas>
      <div class="hudOverlay">
        <div id="msg" class="message show">
          <h2>ğŸ® æ‰“ç£šå¡Š Breakout</h2>
          <p>
            æŒ‰ <span class="kbd">Space</span> é–‹å§‹ / ç™¼çƒï¼Œ<span class="kbd">P</span> æš«åœï¼Œ<span class="kbd">R</span> é‡æ–°é–‹å§‹<br/>
            ç§»å‹•ï¼š<span class="kbd">â† â†’</span> æˆ– <span class="kbd">A D</span>ï¼Œä¹Ÿæ”¯æ´æ»‘é¼ /è§¸æ§æ‹–æ›³
          </p>
        </div>
      </div>
    </div>

    <div class="side">
      <div class="title">
        <h1>Breakout</h1>
        <div class="sub">
          HTML + CSS + JavaScript<br/>
          Canvas ç‰ˆï¼ˆå–®æª”ï¼‰
        </div>
      </div>

      <div class="stats">
        <div class="card">
          <div class="label">åˆ†æ•¸</div>
          <div id="score" class="value">0</div>
        </div>
        <div class="card">
          <div class="label">ç”Ÿå‘½</div>
          <div id="lives" class="value">3</div>
        </div>
        <div class="card">
          <div class="label">é—œå¡</div>
          <div id="level" class="value">1</div>
        </div>
        <div class="card">
          <div class="label">ç‹€æ…‹</div>
          <div id="state" class="value">å¾…é–‹å§‹</div>
        </div>
      </div>

      <div class="controls">
        <button class="primary" id="startBtn">é–‹å§‹ / ç™¼çƒ (Space)</button>
        <button id="pauseBtn">æš«åœ (P)</button>
        <button class="danger" id="restartBtn">é‡ä¾† (R)</button>
      </div>

      <div class="help">
        <strong>ç©æ³•ï¼š</strong> åå½ˆçƒæ‰“æ‰æ‰€æœ‰ç£šå¡Šéé—œã€‚<br/>
        <strong>æŠ€å·§ï¼š</strong> çƒæ‰“åˆ°çƒæ‹ä¸åŒä½ç½®æœƒæ”¹è®Šåå°„è§’åº¦ã€‚<br/>
        <strong>å¿«æ·éµï¼š</strong>
        <span class="kbd">Space</span> é–‹å§‹/ç™¼çƒï¼Œ
        <span class="kbd">P</span> æš«åœï¼Œ
        <span class="kbd">R</span> é‡ä¾†
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas / åŸºæœ¬è¨­å®š =====
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // é«˜ DPI æ”¯æ´ï¼šé¿å…æ¨¡ç³Š
  function setupHiDPI(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const cssW = rect.width, cssH = rect.height;
    // è‹¥ canvas ç”¨ attribute å›ºå®š 960x600ï¼Œé€™è£¡ä¾æ¯”ä¾‹ç¸®æ”¾ç¹ªåœ–åº§æ¨™
    // ç›´æ¥ç”¨å…§å»ºå°ºå¯¸é…åˆç¸®æ”¾å³å¯
    canvas.width = Math.floor(960 * dpr);
    canvas.height = Math.floor(600 * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  // é€™è£¡æ¡å›ºå®šéŠæˆ²åº§æ¨™ 960x600ï¼Œä¸å› è¦–çª—æ”¹è®ŠéŠæˆ²é›£åº¦
  const W = 960, H = 600;

  // ===== UI refs =====
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const levelEl = document.getElementById("level");
  const stateEl = document.getElementById("state");
  const msgEl = document.getElementById("msg");

  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const restartBtn = document.getElementById("restartBtn");

  // ===== éŠæˆ²ç‹€æ…‹ =====
  const GameState = {
    READY: "READY",     // ç­‰ç™¼çƒ
    RUNNING: "RUNNING", // é€²è¡Œä¸­
    PAUSED: "PAUSED",
    WIN: "WIN",
    LOSE: "LOSE"
  };

  let state = GameState.READY;

  // ç‰©ä»¶ï¼šçƒæ‹ã€çƒã€ç£šå¡Š
  const paddle = {
    w: 140,
    h: 16,
    x: W/2 - 70,
    y: H - 48,
    speed: 720, // px/sec
    vx: 0
  };

  const ball = {
    r: 9,
    x: W/2,
    y: H - 70,
    vx: 260,
    vy: -360,
    speedMul: 1.0, // é—œå¡åŠ é€Ÿ
    stuck: true // ç™¼çƒå‰é»åœ¨çƒæ‹ä¸Š
  };

  let score = 0;
  let lives = 3;
  let level = 1;

  // ç£šå¡Šé…ç½®
  const brick = {
    rows: 6,
    cols: 12,
    w: 68,
    h: 22,
    gap: 8,
    top: 72,
    left: 50
  };

  let bricks = [];

  // ===== å·¥å…·å‡½æ•¸ =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random()*(b-a);

  function setState(s){
    state = s;
    const map = {
      READY: "å¾…é–‹å§‹",
      RUNNING: "é€²è¡Œä¸­",
      PAUSED: "æš«åœ",
      WIN: "å‹åˆ©",
      LOSE: "å¤±æ•—"
    };
    stateEl.textContent = map[s] || s;

    // é¡¯ç¤ºè¨Šæ¯
    if (s === GameState.READY){
      msgEl.classList.add("show");
      msgEl.innerHTML = `
        <h2>ğŸ® æ‰“ç£šå¡Š Breakout</h2>
        <p>
          æŒ‰ <span class="kbd">Space</span> é–‹å§‹ / ç™¼çƒï¼Œ<span class="kbd">P</span> æš«åœï¼Œ<span class="kbd">R</span> é‡æ–°é–‹å§‹<br/>
          ç§»å‹•ï¼š<span class="kbd">â† â†’</span> æˆ– <span class="kbd">A D</span>ï¼Œä¹Ÿæ”¯æ´æ»‘é¼ /è§¸æ§æ‹–æ›³
        </p>`;
    } else if (s === GameState.PAUSED){
      msgEl.classList.add("show");
      msgEl.innerHTML = `
        <h2>â¸ å·²æš«åœ</h2>
        <p>æŒ‰ <span class="kbd">P</span> ç¹¼çºŒï¼Œæˆ– <span class="kbd">R</span> é‡ä¾†ã€‚</p>`;
    } else if (s === GameState.WIN){
      msgEl.classList.add("show");
      msgEl.innerHTML = `
        <h2 style="color: #48ff95">ğŸ† éé—œï¼</h2>
        <p>æŒ‰ <span class="kbd">Space</span> é€²å…¥ä¸‹ä¸€é—œï¼ˆçƒé€Ÿæœƒè®Šå¿«ï¼‰ã€‚</p>`;
    } else if (s === GameState.LOSE){
      msgEl.classList.add("show");
      msgEl.innerHTML = `
        <h2 style="color:#ff6b6b">ğŸ’¥ éŠæˆ²çµæŸ</h2>
        <p>åˆ†æ•¸ï¼š<strong>${score}</strong><br/>æŒ‰ <span class="kbd">R</span> é‡æ–°é–‹å§‹ã€‚</p>`;
    } else {
      msgEl.classList.remove("show");
    }
  }

  function resetBallAndPaddle(){
    paddle.x = W/2 - paddle.w/2;
    paddle.vx = 0;

    ball.x = paddle.x + paddle.w/2;
    ball.y = paddle.y - ball.r - 2;
    ball.vx = rand(-240, 240);
    ball.vy = -360;
    ball.stuck = true;
  }

  function buildBricks(){
    bricks = [];
    const palette = ["#6ee7ff", "#48ff95", "#ffd166", "#ff6b6b", "#a78bfa", "#60a5fa"];
    for (let r=0; r<brick.rows; r++){
      for (let c=0; c<brick.cols; c++){
        const x = brick.left + c*(brick.w + brick.gap);
        const y = brick.top + r*(brick.h + brick.gap);
        bricks.push({
          x, y, w: brick.w, h: brick.h,
          alive: true,
          hp: 1, // å¯æ“´å……å¤šè¡€ç£š
          color: palette[r % palette.length]
        });
      }
    }
  }

  function resetGame(){
    score = 0;
    lives = 3;
    level = 1;
    ball.speedMul = 1.0;
    buildBricks();
    resetBallAndPaddle();
    updateHUD();
    setState(GameState.READY);
  }

  function nextLevel(){
    level++;
    ball.speedMul = 1.0 + (level-1)*0.10; // æ¯é—œåŠ é€Ÿ 10%
    // å°å¹…ç¸®çŸ­çƒæ‹ï¼ˆå¢åŠ é›£åº¦ï¼Œä½†ä¸è¦å¤ªèª‡å¼µï¼‰
    paddle.w = clamp(140 - (level-1)*6, 95, 140);
    buildBricks();
    resetBallAndPaddle();
    updateHUD();
    setState(GameState.READY);
  }

  function updateHUD(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    levelEl.textContent = level;
  }

  function allBricksCleared(){
    return bricks.every(b => !b.alive);
  }

  // ===== ç¢°æ’æª¢æ¸¬èˆ‡åå½ˆ =====
  function circleRectCollision(cx, cy, r, rx, ry, rw, rh){
    // æ‰¾åˆ°åœ“å¿ƒåˆ°çŸ©å½¢æœ€è¿‘é»
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx;
    const dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  function reflectBallOffPaddle(){
    // æ ¹æ“šæ‰“åˆ°çƒæ‹çš„ä½ç½®æ±ºå®šè§’åº¦ï¼ˆä¸­å¿ƒ=ç›´ä¸Šï¼Œé‚Šç·£=æ–œï¼‰
    const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
    const angle = hit * (Math.PI * 0.35); // æœ€å¤§ç´„ 63 åº¦
    const speed = Math.hypot(ball.vx, ball.vy);
    ball.vx = speed * Math.sin(angle);
    ball.vy = -Math.abs(speed * Math.cos(angle));
  }

  // ===== è¼¸å…¥ï¼šéµç›¤ / æ»‘é¼  / è§¸æ§ =====
  const keys = { left:false, right:false };

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") keys.left = true;
    if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") keys.right = true;

    if (e.code === "Space"){
      e.preventDefault();
      handleStartOrLaunch();
    }
    if (e.key.toLowerCase() === "p"){
      togglePause();
    }
    if (e.key.toLowerCase() === "r"){
      resetGame();
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") keys.left = false;
    if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") keys.right = false;
  });

  function canvasToGameX(clientX){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) / rect.width * W;
    return x;
  }

  function movePaddleTo(x){
    paddle.x = clamp(x - paddle.w/2, 12, W - paddle.w - 12);
  }

  // æ»‘é¼ 
  window.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    if (e.clientY < rect.top || e.clientY > rect.bottom) return;
    movePaddleTo(canvasToGameX(e.clientX));
  }, { passive:true });

  // è§¸æ§
  window.addEventListener("touchstart", (e) => {
    if (!e.touches?.length) return;
    movePaddleTo(canvasToGameX(e.touches[0].clientX));
  }, { passive:true });

  window.addEventListener("touchmove", (e) => {
    if (!e.touches?.length) return;
    movePaddleTo(canvasToGameX(e.touches[0].clientX));
  }, { passive:true });

  // Buttons
  startBtn.addEventListener("click", handleStartOrLaunch);
  pauseBtn.addEventListener("click", togglePause);
  restartBtn.addEventListener("click", resetGame);

  function handleStartOrLaunch(){
    if (state === GameState.LOSE) return;
    if (state === GameState.WIN){
      nextLevel();
      return;
    }
    if (state === GameState.PAUSED){
      setState(GameState.RUNNING);
      return;
    }
    if (state === GameState.READY){
      // ç™¼çƒ
      ball.stuck = false;
      setState(GameState.RUNNING);
      msgEl.classList.remove("show");
      return;
    }
    // RUNNING æ™‚æŒ‰ Spaceï¼šä¸åšäº‹ï¼ˆä½ ä¹Ÿå¯ä»¥æ”¹æˆâ€œåŠ é€Ÿâ€ï¼‰
  }

  function togglePause(){
    if (state === GameState.RUNNING){
      setState(GameState.PAUSED);
    } else if (state === GameState.PAUSED){
      setState(GameState.RUNNING);
      msgEl.classList.remove("show");
    }
  }

  // ===== éŠæˆ²å¾ªç’° =====
  let last = performance.now();

  function step(now){
    const dt = Math.min(0.033, (now - last) / 1000); // é¿å…åˆ‡æ›åˆ†é é€ æˆå¤§ dt
    last = now;

    update(dt);
    draw();

    requestAnimationFrame(step);
  }

  function update(dt){
    // paddle ç”±éµç›¤æ§åˆ¶ï¼ˆæ»‘é¼ /è§¸æ§å‰‡ç›´æ¥å®šä½ï¼Œä¸ä¾è³´ vxï¼‰
    paddle.vx = 0;
    if (keys.left) paddle.vx -= paddle.speed;
    if (keys.right) paddle.vx += paddle.speed;
    paddle.x = clamp(paddle.x + paddle.vx * dt, 12, W - paddle.w - 12);

    // READY ç‹€æ…‹çƒé»åœ¨çƒæ‹ä¸Š
    if (ball.stuck){
      ball.x = paddle.x + paddle.w/2;
      ball.y = paddle.y - ball.r - 2;
      return;
    }

    if (state !== GameState.RUNNING) return;

    // ç§»å‹•çƒ
    const mul = ball.speedMul;
    ball.x += ball.vx * dt * mul;
    ball.y += ball.vy * dt * mul;

    // ç‰†åå½ˆ
    if (ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
    if (ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx *= -1; }
    if (ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }

    // æ‰è½åº•éƒ¨
    if (ball.y - ball.r > H){
      lives--;
      updateHUD();
      if (lives <= 0){
        setState(GameState.LOSE);
        return;
      }
      resetBallAndPaddle();
      setState(GameState.READY);
      return;
    }

    // çƒæ‹ç¢°æ’
    if (circleRectCollision(ball.x, ball.y, ball.r, paddle.x, paddle.y, paddle.w, paddle.h) && ball.vy > 0){
      ball.y = paddle.y - ball.r - 0.5;
      reflectBallOffPaddle();
    }

    // ç£šå¡Šç¢°æ’ï¼ˆç°¡å–®è™•ç†ï¼šç¢°åˆ°å°±æ¶ˆå¤±ä¸¦åè½‰ y æˆ– xï¼‰
    for (const b of bricks){
      if (!b.alive) continue;
      if (circleRectCollision(ball.x, ball.y, ball.r, b.x, b.y, b.w, b.h)){
        b.hp--;
        if (b.hp <= 0) b.alive = false;

        score += 10;
        updateHUD();

        // åˆ¤æ–·ç¢°æ’æ–¹å‘ï¼šç”¨å‰ä¸€å¹€ä½ç½®ä¼°è¨ˆ
        // ä»¥çƒå¿ƒé€Ÿåº¦æ–¹å‘åšç°¡åŒ–åå°„
        const overlapLeft = (ball.x + ball.r) - b.x;
        const overlapRight = (b.x + b.w) - (ball.x - ball.r);
        const overlapTop = (ball.y + ball.r) - b.y;
        const overlapBottom = (b.y + b.h) - (ball.y - ball.r);
        const minX = Math.min(overlapLeft, overlapRight);
        const minY = Math.min(overlapTop, overlapBottom);

        if (minX < minY) ball.vx *= -1;
        else ball.vy *= -1;

        break; // ä¸€æ¬¡åªè™•ç†ä¸€å¡Šï¼Œé¿å…é€£é–ç©¿é€
      }
    }

    // éé—œ
    if (allBricksCleared()){
      setState(GameState.WIN);
      ball.stuck = true;
      return;
    }
  }

  // ===== ç¹ªåœ– =====
  function draw(){
    // èƒŒæ™¯æ¸…é™¤
    ctx.clearRect(0, 0, W, H);

    // æ˜Ÿé» / è£é£¾
    drawStars();

    // ç£šå¡Š
    for (const b of bricks){
      if (!b.alive) continue;
      drawBrick(b);
    }

    // çƒæ‹
    drawPaddle();

    // çƒ
    drawBall();

    // ä¸Šæ–¹ HUDï¼ˆCanvas ä¸Šä¹Ÿç•«ä¸€ä»½ï¼‰
    drawTopHUD();
  }

  function drawStars(){
    // ç°¡å–®ç²’å­èƒŒæ™¯ï¼šå›ºå®š seed é¢¨æ ¼
    ctx.save();
    ctx.globalAlpha = 0.25;
    for (let i=0;i<55;i++){
      const x = (i*173) % W;
      const y = (i*97) % H;
      const r = (i%3)+1;
      ctx.fillStyle = i%2 ? "#6ee7ff" : "#ffffff";
      ctx.beginPath();
      ctx.arc(x, y, r*0.6, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawBrick(b){
    ctx.save();
    // é™°å½±
    ctx.fillStyle = "rgba(0,0,0,.25)";
    roundRect(ctx, b.x+2, b.y+3, b.w, b.h, 8);
    ctx.fill();

    // ä¸»é«”
    const grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
    grad.addColorStop(0, hexToRgba(b.color, 0.95));
    grad.addColorStop(1, hexToRgba("#000000", 0.25));
    ctx.fillStyle = grad;
    roundRect(ctx, b.x, b.y, b.w, b.h, 8);
    ctx.fill();

    // é«˜å…‰
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 1;
    roundRect(ctx, b.x+1, b.y+1, b.w-2, b.h-2, 7);
    ctx.stroke();
    ctx.restore();
  }

  function drawPaddle(){
    ctx.save();
    const x = paddle.x, y = paddle.y;
    // é™°å½±
    ctx.fillStyle = "rgba(0,0,0,.35)";
    roundRect(ctx, x+3, y+4, paddle.w, paddle.h, 10);
    ctx.fill();

    // ä¸»é«”
    const grad = ctx.createLinearGradient(x, y, x+paddle.w, y);
    grad.addColorStop(0, "rgba(110,231,255,.65)");
    grad.addColorStop(0.5, "rgba(72,255,149,.75)");
    grad.addColorStop(1, "rgba(167,139,250,.65)");
    ctx.fillStyle = grad;
    roundRect(ctx, x, y, paddle.w, paddle.h, 10);
    ctx.fill();

    // é«˜å…‰
    ctx.strokeStyle = "rgba(255,255,255,.22)";
    ctx.lineWidth = 1;
    roundRect(ctx, x+1, y+1, paddle.w-2, paddle.h-2, 9);
    ctx.stroke();
    ctx.restore();
  }

  function drawBall(){
    ctx.save();
    // é™°å½±
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.beginPath();
    ctx.arc(ball.x+2, ball.y+3, ball.r, 0, Math.PI*2);
    ctx.fill();

    // çƒé«”
    const grad = ctx.createRadialGradient(ball.x-3, ball.y-4, 2, ball.x, ball.y, ball.r+6);
    grad.addColorStop(0, "rgba(255,255,255,1)");
    grad.addColorStop(0.35, "rgba(110,231,255,.95)");
    grad.addColorStop(1, "rgba(30,136,229,.65)");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawTopHUD(){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.30)";
    ctx.fillRect(0, 0, W, 44);

    ctx.fillStyle = "rgba(234,240,255,.90)";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC, sans-serif";
    ctx.fillText(`åˆ†æ•¸: ${score}`, 16, 28);
    ctx.fillText(`ç”Ÿå‘½: ${lives}`, 130, 28);
    ctx.fillText(`é—œå¡: ${level}`, 240, 28);

    const tip = (state === GameState.READY) ? "Space ç™¼çƒ" :
                (state === GameState.RUNNING) ? "P æš«åœ" :
                (state === GameState.PAUSED) ? "P ç¹¼çºŒ" :
                (state === GameState.WIN) ? "Space ä¸‹ä¸€é—œ" :
                "R é‡ä¾†";
    ctx.fillStyle = "rgba(110,231,255,.95)";
    ctx.fillText(tip, W - 120, 28);
    ctx.restore();
  }

  // ===== å°å·¥å…·ï¼šåœ“è§’çŸ©å½¢ / è‰²å½© =====
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }
  function hexToRgba(hex, a=1){
    const h = hex.replace("#","");
    const bigint = parseInt(h.length===3 ? h.split("").map(x=>x+x).join("") : h, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `rgba(${r},${g},${b},${a})`;
  }

  // ===== Resize / Init =====
  function onResize(){
    // è®“ canvas CSS è‡ªé©æ‡‰å®¹å™¨ï¼Œä½†ç¹ªåœ–åº§æ¨™ä»ä»¥ 960x600
    // é€™è£¡åªéœ€è¦ç¢ºä¿ dpr transform æ­£ç¢ºï¼ˆä¸ä¾è³´ rect å¤§å°ï¼‰
    setupHiDPI();
  }
  window.addEventListener("resize", onResize);

  // init
  onResize();
  resetGame();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
